{
  "name": "protocol",
  "id": "protocol",
  "version": "0.4.0",
  "description": "Protocol based polymorphism for javascript.",
  "keywords": [
    "polymorphism",
    "protocol",
    "cotract"
  ],
  "author": {
    "name": "Irakli Gozalishvili",
    "email": "rfobic@gmail.com",
    "url": "http://jeditoolkit.com"
  },
  "homepage": "https://github.com/Gozala/protocol",
  "repository": {
    "type": "git",
    "url": "https://github.com/Gozala/protocol.git",
    "web": "https://github.com/Gozala/protocol"
  },
  "bugs": {
    "url": "http://github.com/Gozala/protocol/issues/"
  },
  "devDependencies": {
    "test": ">=0.0.10",
    "repl-utils": ">=0.0.1",
    "swank-js": ">=0.0.1"
  },
  "engines": {
    "node": ">=0.4.x"
  },
  "main": "./core.js",
  "scripts": {
    "test": "node tests/test-all.js",
    "repl": "node ./node_modules/repl-utils",
    "swank": "node ./node_modules/swank-js"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://jeditoolkit.com/LICENSE"
    }
  ],
  "readme": "# Protocol\n\n[![build status](https://secure.travis-ci.org/Gozala/protocol.png)](http://travis-ci.org/Gozala/protocol)\n\nProtocol JS library is inspired by idea of [clojure protocols]. Protocols\nprovide a powerful way for decoupling abstraction interface definition from\nan actual implementation per type, without risks of interference with other\nlibraries.\n\nThere are several motivations for protocols:\n\n- Provide a high-performance, dynamic polymorphism construct as an alternative\n  to existing object inheritance that does not provides any mechanics for\n  guarding against name conflicts.\n- Provide the best parts of interfaces:\n    - specification only, no implementation\n    - a single type can implement multiple protocols\n- Protocols allow independent extension of the set of types, protocols, and\n  implementations of protocols on types, by different parties.\n\n## Basics\n\nA protocol is a named set of function signatures:\n\n```js\nvar protocol = require('protocol/core').protocol\n\nvar Sequential = protocol({\n  first: ('Returns first item of this sequence', [ protocol ]),\n  rest: ('Returns sequence of items after the first', [ protocol ]),\n  join: ('Returns sequence of items where head is first, and this is rest', [ Object, protocol ])\n})\n```\n\n- No implementations are provided\n- Docs can be optionally specified for the protocol and the functions, via\n  elegant JS hack.\n- The above yields a set of polymorphic functions and a protocol object\n- The resulting functions dispatch on the type of their `protocol` argument,\n  and thus must have it in the list of arguments.\n\n`protocol` will generate an interface containing a corresponding functions.\nreturned interface may be used to extend data types with it's implementations:\n\n```js\nSequential(Array, {\n  first: function(array) { return array[0] || null },\n  rest: function(array) { return Array.prototype.slice.call(array, 1) },\n  join: function(item, array) {\n    return Array.prototype.concat.call([ item ], array)\n  }\n})\n```\n\nOnce protocol is implemented for a given type it can be used with a given data\ntypes:\n\n```js\nSequential.first([ 1, 2, 3 ]) // => 1\nSequential.rest([ 1, 2, 3 ])  // => [ 2, 3 ]\n\nSequential.first('hello')     // TypeError: Protocol not implemented: first\n```\n\nProtocol may be implemented for any other data types by any other party:\n\n```js\nSequential(String, {\n  first: function(string) { return string[0] || null },\n  rest: function(string) { return String.prototype.substr.call(string, 1) },\n  join: function(item, string) { return item + string }\n})\n\nSequential.first('hello')     // => 'h'\n```\n\nProtocol implementation may be provided to all the data types by ommiting\ntype argument:\n\n```js\nSequential({\n  first: function(_) { return _ },\n  rest: function(_) { return null }\n})\n\nSequential.head(5)          // => 5\nSequential.tail(3)          // => null\n```\n\nSince protocol implementations are decoupled from the actual protocol\ndefinition there maybe multiple implementations, but user will be in charge of\ndeciding which one to pull in.\n\n## Argument pattern based dispatch\n\nThis library previously was doing argument pattern based method dispatch.\nIf you are looking into something more in that line, check out [dispatcher]\nlibrary that was forked from protocol to explore that direction.\n\n[dispatcher]:https://github.com/Gozala/dispatcher/ \"Argument patter based dispatch\"\n[clojure protocols]:http://clojure.org/protocols \"Clojure protocols\"\n",
  "_id": "protocol@0.4.0",
  "dist": {
    "shasum": "3ff18a20f4237b701bb4bc81bb6f09aa311527f4"
  },
  "_from": "protocol"
}
